// Lab 5, HeapSort, MergeSort, and Quick Sort of Pet pointers
// Todd Pieper
// CPSC 2430

#include <iostream>
#include <chrono>
using namespace std;
using namespace chrono;

struct Pet{

    string name;
    int weight;

    Pet(string petName, int petWeight) {
      name = petName;
      weight = petWeight;
    }
};

struct MaxHeap{

  int numPets;
  Pet** petHeap;
  
  void percolateUp(int index);
  void percolateDown(int index);
  char whichChildrenToCheck(int index);
  void maxSort();
  Pet* petMax(Pet* pet1, Pet* pet2);

  MaxHeap(Pet* A[], int n);
  ~MaxHeap();
};

void heapSort(Pet* A[], int n);

void quickSort(Pet* A[], int n);
void quickHelp(Pet* A[], int i, int j);
int partition(Pet* A[], int i, int j);
int partitionRandom(Pet* A[], int i, int j);

void mergeSort(Pet* A[], int n);
void mergeHelp(Pet* A[], int i, int j);
void merge(Pet* A[], int p, int q, int r);

void printArray(Pet* A[], int n);
void measureSort(void (*sortingFunction)(Pet*[], int));

          int main() {

  // function pointer
  void (*sortingFunction)(Pet*[], int);

  cout << endl << "HEAP SORT" << endl;
  sortingFunction = &heapSort;
  measureSort(sortingFunction);

  cout << endl << "MERGE SORT" << endl;
  sortingFunction = &mergeSort;
  measureSort(sortingFunction);

  cout << endl << "QUICK SORT" << endl;
  sortingFunction = &quickSort;
  measureSort(sortingFunction);
}









void mergeSort(Pet* A[], int n) {

  mergeHelp(A, 0, n-1);

}

void mergeHelp(Pet* A[], int i, int j) {

  if (i < j) {

    int mid = (i+j)/2;
    mergeHelp(A, i, mid);
    mergeHelp(A, mid+1, j);
    merge(A, i, mid, j);

  }

}

void merge(Pet* A[], int p, int q, int r) {

  int size = (r-p) + 1;
  int index = 0;

  Pet** merged = new Pet*[size]{nullptr};

  int left = p;
  int right = q+1;

  while (left <= q && right <= r) {

    if (A[left]->weight <= A[right]->weight) {

      merged[index] = A[left];
      left++;

    } else {

      merged[index] = A[right];
      right++;

    }
    index++;



  } // end of first while

  while (left <= q) { //Left side remains unsorted, add to the end

    merged[index] = A[left];
    left++;
    index++;

  }
  while (right < r+1) { //Right side remains unsorted, add to the end

    merged[index] = A[right];
    right++;
    index++;

  }

  for (int k = 0; k < size; k++) {
    A[p] = merged[k];
    p++;

  }
  
  delete[] merged;

}

void quickSort(Pet* A[], int n) {

  quickHelp(A, 0, n-1);

}

void quickHelp(Pet* A[], int i, int j) {

  if (i < j) {

    int pivotIndex = partitionRandom(A, i, j);
    quickHelp(A, i, pivotIndex-1);
    quickHelp(A, pivotIndex +1, j);

  }

}

int partitionRandom(Pet* A[], int i, int j) {

  int randomPosition = i + rand() % (j - i + 1);
  swap(A[i], A[randomPosition]);
  return partition(A, i, j);

}

int partition(Pet* A[], int i, int j) {

  int pivotElement = A[i]->weight;
  int s1 = i, s2 = i;

  for (int k = i+1; k <= j; k++) {

    if (pivotElement < A[k]->weight) {
      s2++;

    } else {

      s1++;
      swap(A[s1], A[k]);
      s2++;

    }

  }

  swap(A[s1], A[i]);
  return s1;
}

void measureSort(void (*sortingFunction)(Pet*[], int)) {

  int sizeTracker;
  int size[] = {10, 100, 1000, 10000, 100000};
  for (int i = 0; i < 5; i++) {

    sizeTracker = size[i];
    //allocate memory for the array of size[i]
    Pet **array = new Pet *[sizeTracker];

    // fill in array with random numbers
    for (int j = 0; j < sizeTracker; j++) {

      string name = "J";
      int weight = rand() % 100000;
      array[j] = new Pet(name, weight);

    }

    if (sizeTracker == 10) {
      cout << "Random array size " << sizeTracker << ": " << endl;
      printArray(array, sizeTracker);
    }

    // Call the sorting function (make sure to
    // start with a new unsorted array each time)
    // and measure the execution time here
    auto start = high_resolution_clock::now();
    sortingFunction(array, sizeTracker);
    auto stop = high_resolution_clock::now();
    auto duration = stop - start;
    auto duration_ns = duration_cast<nanoseconds>(duration);

    if (sizeTracker == 10) {
      cout << "Sorted Array size " << sizeTracker << ": " << endl;
      printArray(array, sizeTracker);
    }
    cout << "Array size " << sizeTracker << " duration: ";
    cout << duration_ns.count() << " ns." << endl; // match your time units

    //Iterate over each row to delete the "horizontal" arrays first
    for(int k =0; k < sizeTracker; k++) {
      delete array[k];

    }
    //And finally delete the "vertical" pointer array
    delete[] array;

  }

}


void printArray(Pet* A[], int n) {

  for (int i = 0; i < n; i++) {

    cout << A[i]->weight << ", ";
  }
  cout << endl;
}


void heapSort(Pet* A[], int n) {

  cout << "hello" << endl;
  MaxHeap heap(A, n);
  cout << "hi" << endl;
  printArray(heap.petHeap, n);
  heap.maxSort();

  for (int i = 0; i < n; i++) {
    A[i] = heap.petHeap[i];
  }

}

MaxHeap::MaxHeap(Pet* A[], int n) {  

  petHeap = new Pet*[n];
  numPets = n;
  for (int i = 0; i < n; i++) {
    petHeap[i] = A[i];
    percolateUp(i);
  }

}

MaxHeap::~MaxHeap() {

  delete[] petHeap;

}

void MaxHeap::maxSort() {

  while (numPets > 0) {
    numPets--;
    swap(petHeap[0], petHeap[numPets]);
    percolateDown(0);

  }
  
}

// PERCOLATE UP FUNCTION
// Will be called as part of our insert function, since we are building a MaxHeap we calculate
// the parent index of the child we have added at index and compare the ages, if the parent is
// younger, we will use our helper function and swap the two pets and continue to call percolate
// up at the parent index (since we swapped the values we will keep following the child) until
// we reach a parent that is older than the child we are moving up, or we have made it all the
// way to the root, index 0
void MaxHeap::percolateUp(int index) {

    if (index == 0) {
        return;

    }

    int parent = (index-1) / 2;

    if (petHeap[parent]->weight <  petHeap[index]->weight) {

        swap(petHeap[parent], petHeap[index]);
        percolateUp(parent);

    }
    return;

}

// PERCOLATE DOWN FUNCTION
// Will be called as part of our delete function, since we are building a MaxHeap we calculate
// the index of our nodes children and
void MaxHeap::percolateDown(int index) {

  Pet* leftChild;
    int leftChildIndex;

    switch (whichChildrenToCheck(index)) { // Call helper function to know which children to check for

        case 'n': // case 'n', node at index has no children, so we can't move it down any more than it's current position
            break;


        // Case 'f' Index is out of bounds, this is an error case that should never happen, we will print a message
        // to terminal for the event it gets called
        case 'f':
            cout << endl << "Error, and index outside of the heaps size was called to percolate down!" << endl;
            break;

        // Cae 'l' Node only has a left child
        case 'l':
            leftChildIndex = 2*index + 1;
            if (petHeap[leftChildIndex]->weight > petHeap[index]->weight) {
                swap(petHeap[index], petHeap[leftChildIndex]);
                percolateDown(leftChildIndex);
                
            }
            break;

        case 'b': // case both children exist in our heap

            int rightChildIndex = 2*index + 2;
            leftChildIndex = 2*index + 1;
            Pet* rightChild = petHeap[rightChildIndex];
            leftChild = petHeap[leftChildIndex];
            Pet* largest = petMax(leftChild, rightChild);

            if (largest->weight > petHeap[index]->weight) {

              if (leftChild == largest) {
                swap(petHeap[index], petHeap[leftChildIndex]);
                percolateDown(leftChildIndex);

              } else {
                swap(petHeap[index], petHeap[rightChildIndex]);
                percolateDown(rightChildIndex);

            }

            }
            break;



    } //end of switch

} // end of percolate down

// WHICH CHILDREN TO CHECK HELPER FUNCTION
// Helper function to feed into a switch choice for percolate down since we need to do different comparisons based on
// whether a not a node has kids and which ones if it does have some.
// The switch choice will act accordingly to the char returned by this function
char MaxHeap::whichChildrenToCheck(int index) {

    int indexLC = 2*index + 1;
    int indexRC = 2*index + 2;

    if (index > numPets) { //Index is out of bounds, return 'f' for failed index
        return 'f';

        // If the right child is within the array bounds, since this is a complete tree, there will be a left child guaranteed
        // return 'b' for both children
    } else if (indexRC < numPets) {
        return 'b';

        // Similar to logic above, if the left child is out of bounds of our array,  we don't have to check the right
        // since we know it doesn't exist return 'n' for none
    } else if ( indexLC >= numPets) {
        return 'n';

    } else { // Final case is just having a left child since our nodes will never have just a right, return 'l' for left
        return 'l';

    }
}

Pet* MaxHeap::petMax(Pet* pet1, Pet* pet2) {

  if (pet1->weight >= pet2->weight) {
      return pet1;

  } else {
      return pet2;

  }
  return nullptr;
}
